# classes/ForeuseBehavior.py
from typing import Optional, Tuple, List
from classes.Point import Type, Point
from classes.Ship import Ship, Foreuse
import random

class ForeuseBehavior:
    """
    G√®re le comportement automatique d'une Foreuse.
    
    Strat√©gie :
    1. Chercher un ast√©ro√Øde ou une plan√®te √† proximit√©
    2. Se d√©placer vers la cible
    3. Rester √† c√¥t√© pour que Turn g√®re le minage
    """
    
    def __init__(self, foreuse: Foreuse):
        self.foreuse = foreuse
        self.cible_actuelle: Optional[Tuple[int, int]] = None
        self.mode = "recherche"  # "recherche", "deplacement", "attente"
        print(f"[IA Foreuse {self.foreuse.id}] Initialisation")
        
    def trouver_ressource_proche(self, grille: List[List[Point]], 
                                  rayon_recherche: int = 15) -> Optional[Tuple[int, int]]:
        """
        Trouve l'ast√©ro√Øde ou la plan√®te la plus proche dans un rayon donn√©.
        Priorit√© : ast√©ro√Ødes > plan√®tes
        """
        pos_foreuse = (self.foreuse.cordonner.x, self.foreuse.cordonner.y)
        print(f"[IA Foreuse {self.foreuse.id}] Position actuelle: {pos_foreuse}")
        
        # Listes pour stocker les ressources trouv√©es
        asteroides = []
        planetes = []
        
        # Parcourir la zone autour de la foreuse
        for dl in range(-rayon_recherche, rayon_recherche + 1):
            for dc in range(-rayon_recherche, rayon_recherche + 1):
                ligne = pos_foreuse[0] + dl
                col = pos_foreuse[1] + dc
                
                # V√©rifier les limites
                if 0 <= ligne < len(grille) and 0 <= col < len(grille[0]):
                    case = grille[ligne][col]
                    
                    # Distance de Manhattan
                    distance = abs(dl) + abs(dc)
                    
                    if case.type == Type.ASTEROIDE:
                        asteroides.append((ligne, col, distance))
                        print(f"[IA Foreuse {self.foreuse.id}] Ast√©ro√Øde trouv√© √† ({ligne}, {col}), distance: {distance}")
                    elif case.type == Type.PLANETE:
                        planetes.append((ligne, col, distance))
        
        print(f"[IA Foreuse {self.foreuse.id}] Trouv√© {len(asteroides)} ast√©ro√Ødes et {len(planetes)} plan√®tes")
        
        # Priorit√© aux ast√©ro√Ødes (plus rentables)
        if asteroides:
            asteroides.sort(key=lambda x: x[2])
            cible = (asteroides[0][0], asteroides[0][1])
            print(f"[IA Foreuse {self.foreuse.id}] Cible choisie (ast√©ro√Øde): {cible}")
            return cible
        
        if planetes:
            planetes.sort(key=lambda x: x[2])
            cible = (planetes[0][0], planetes[0][1])
            print(f"[IA Foreuse {self.foreuse.id}] Cible choisie (plan√®te): {cible}")
            return cible
        
        print(f"[IA Foreuse {self.foreuse.id}] Aucune ressource trouv√©e dans le rayon {rayon_recherche}")
        return None
    
    def trouver_case_adjacente_libre(self, cible: Tuple[int, int], 
                                      grille: List[List[Point]]) -> Optional[Tuple[int, int]]:
        """
        Trouve une case libre adjacente √† la cible pour se positionner.
        """
        ligne_cible, col_cible = cible
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # haut, bas, gauche, droite
        
        cases_libres = []
        
        print(f"[IA Foreuse {self.foreuse.id}] Recherche case adjacente √† ({ligne_cible}, {col_cible})")
        
        for dl, dc in directions:
            ligne = ligne_cible + dl
            col = col_cible + dc
            
            # V√©rifier si la case est dans les limites
            if (0 <= ligne < len(grille) and 0 <= col < len(grille[0])):
                print(f"[IA Foreuse {self.foreuse.id}] Test case ({ligne}, {col})")
                
                # V√©rifier collision
                if self.foreuse.verifier_collision(grille, ligne, col, 
                                                   self.foreuse.direction, 
                                                   ignorer_self=True):
                    cases_libres.append((ligne, col))
                    print(f"[IA Foreuse {self.foreuse.id}] Case ({ligne}, {col}) est LIBRE")
                else:
                    print(f"[IA Foreuse {self.foreuse.id}] Case ({ligne}, {col}) est OCCUP√âE")
        
        if cases_libres:
            print(f"[IA Foreuse {self.foreuse.id}] {len(cases_libres)} cases libres trouv√©es")
            return cases_libres[0]
        else:
            print(f"[IA Foreuse {self.foreuse.id}] AUCUNE case libre trouv√©e")
            return None
    
    def est_adjacent_a_cible(self, cible: Tuple[int, int]) -> bool:
        """
        V√©rifie si la foreuse est adjacente √† la cible.
        """
        pos = (self.foreuse.cordonner.x, self.foreuse.cordonner.y)
        distance = abs(pos[0] - cible[0]) + abs(pos[1] - cible[1])
        est_adjacent = distance == 1
        
        print(f"[IA Foreuse {self.foreuse.id}] Distance √† cible {cible}: {distance}, adjacent: {est_adjacent}")
        return est_adjacent
    
    def executer_tour(self, grille: List[List[Point]], ships: List[Ship]) -> bool:
        """
        Ex√©cute le comportement de la foreuse pour un tour.
        UNIQUEMENT LE D√âPLACEMENT, pas le minage.
        """
        print(f"\n{'='*60}")
        print(f"[IA Foreuse {self.foreuse.id}] === D√âBUT DU TOUR ===")
        print(f"[IA Foreuse {self.foreuse.id}] Port√©e d√©placement: {self.foreuse.port_deplacement}")
        print(f"[IA Foreuse {self.foreuse.id}] Mode: {self.mode}")
        print(f"[IA Foreuse {self.foreuse.id}] Cible actuelle: {self.cible_actuelle}")
        
        # Si plus de port√©e de d√©placement, ne rien faire
        if self.foreuse.port_deplacement <= 0:
            print(f"[IA Foreuse {self.foreuse.id}] ‚ùå Plus de port√©e de d√©placement")
            return False
        
        # === MODE RECHERCHE ===
        if self.mode == "recherche" or self.cible_actuelle is None:
            print(f"[IA Foreuse {self.foreuse.id}] üîç MODE RECHERCHE")
            self.cible_actuelle = self.trouver_ressource_proche(grille)
            
            if self.cible_actuelle is None:
                print(f"[IA Foreuse {self.foreuse.id}] ‚ö†Ô∏è Aucune ressource trouv√©e, d√©placement al√©atoire")
                return self.deplacer_aleatoirement(grille, ships)
            
            self.mode = "deplacement"
            print(f"[IA Foreuse {self.foreuse.id}] ‚úì Passage en mode D√âPLACEMENT")
        
        # === V√âRIFIER SI D√âJ√Ä ADJACENT ===
        if self.est_adjacent_a_cible(self.cible_actuelle):
            print(f"[IA Foreuse {self.foreuse.id}] ‚úì D√âJ√Ä ADJACENT √† la cible {self.cible_actuelle}")
            
            # V√©rifier si la cible existe encore
            ligne_cible, col_cible = self.cible_actuelle
            type_case = grille[ligne_cible][col_cible].type
            
            print(f"[IA Foreuse {self.foreuse.id}] Type de case cible: {type_case}")
            
            if type_case in [Type.ASTEROIDE, Type.PLANETE]:
                # Rester en place, Turn g√©rera le minage
                print(f"[IA Foreuse {self.foreuse.id}] üíé Reste en place pour minage automatique")
                self.mode = "attente"
                return False  # Pas de d√©placement
            else:
                # La cible n'existe plus, chercher une nouvelle cible
                print(f"[IA Foreuse {self.foreuse.id}] ‚ö†Ô∏è Cible disparue, nouvelle recherche")
                self.cible_actuelle = None
                self.mode = "recherche"
                return False
        
        # === MODE D√âPLACEMENT ===
        print(f"[IA Foreuse {self.foreuse.id}] üöÄ MODE D√âPLACEMENT vers {self.cible_actuelle}")
        
        # Trouver une case adjacente √† la cible
        case_adjacente = self.trouver_case_adjacente_libre(self.cible_actuelle, grille)
        
        if case_adjacente is None:
            print(f"[IA Foreuse {self.foreuse.id}] ‚ùå Cible inatteignable, nouvelle recherche")
            self.cible_actuelle = None
            self.mode = "recherche"
            return False
        
        print(f"[IA Foreuse {self.foreuse.id}] üéØ Tentative de d√©placement vers {case_adjacente}")
        
        # Se d√©placer vers la case adjacente
        success = self.foreuse.deplacement(case_adjacente, grille, ships)
        
        if success:
            print(f"[IA Foreuse {self.foreuse.id}] ‚úÖ D√âPLACEMENT R√âUSSI vers {case_adjacente}")
            print(f"[IA Foreuse {self.foreuse.id}] Nouvelle position: ({self.foreuse.cordonner.x}, {self.foreuse.cordonner.y})")
            print(f"[IA Foreuse {self.foreuse.id}] Port√©e restante: {self.foreuse.port_deplacement}")
            return True
        else:
            print(f"[IA Foreuse {self.foreuse.id}] ‚ùå D√âPLACEMENT √âCHOU√â")
            # D√©placement impossible, chercher une autre cible
            self.cible_actuelle = None
            self.mode = "recherche"
            return False
    
    def deplacer_aleatoirement(self, grille: List[List[Point]], ships: List[Ship]) -> bool:
        """
        D√©place la foreuse vers une position al√©atoire accessible.
        """
        print(f"[IA Foreuse {self.foreuse.id}] üé≤ D√©placement al√©atoire")
        
        positions = self.foreuse.positions_possibles_adjacentes(grille)
        print(f"[IA Foreuse {self.foreuse.id}] {len(positions)} positions possibles")
        
        if positions:
            position_aleatoire = random.choice(positions)
            print(f"[IA Foreuse {self.foreuse.id}] Position choisie: {position_aleatoire}")
            
            success = self.foreuse.deplacement(position_aleatoire, grille, ships)
            
            if success:
                print(f"[IA Foreuse {self.foreuse.id}] ‚úÖ D√©placement al√©atoire R√âUSSI")
                return True
            else:
                print(f"[IA Foreuse {self.foreuse.id}] ‚ùå D√©placement al√©atoire √âCHOU√â")
        else:
            print(f"[IA Foreuse {self.foreuse.id}] ‚ùå Aucune position accessible")
        
        return False
    
    def reset(self):
        """R√©initialise l'√©tat de l'IA (appel√© en d√©but de tour)."""
        print(f"[IA Foreuse {self.foreuse.id}] üîÑ RESET de l'IA")
        if self.mode == "attente":
            # Si on √©tait en attente de minage, on reste sur la m√™me cible
            self.mode = "deplacement"
            print(f"[IA Foreuse {self.foreuse.id}] Mode attente -> d√©placement")
        # Ne pas r√©initialiser la cible si on est d√©j√† en cours